{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NDF Studio Backend Documentation","text":"<p>Welcome to the comprehensive documentation for the NDF Studio backend API and implementation.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>NDF Studio is a Node-neighborhood Description Framework that provides a powerful backend API for managing graph-based knowledge representations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Graph Management: Create, update, and manage complex graph structures</li> <li>Node Operations: Handle polymorphic nodes with multiple morphs</li> <li>Relation Management: Define and manage relationships between nodes</li> <li>Authentication: Secure user management with JWT tokens</li> <li>CNL Parsing: Natural language processing for graph descriptions</li> </ul>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":""},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Core Modules: Core functionality including models, utilities, and validation</li> <li>Routes: API endpoints for graph operations, user management, and more</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Installation: Setup instructions for developers</li> </ul>"},{"location":"#getting-started","title":"\ud83d\udd27 Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>FastAPI</li> <li>SQLModel</li> <li>spaCy</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/gnowledge/nodeBook.git\ncd nodeBook\n\n# Install dependencies\npip install -r backend/requirements.txt\n\n# Run the development server\nbash scripts/start_backend.sh\n</code></pre>"},{"location":"#api-access","title":"API Access","text":"<p>Once running, you can access: - API Documentation: http://localhost:8000/docs - Alternative Docs: http://localhost:8000/redoc - Health Check: http://localhost:8000/api/health</p>"},{"location":"#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<p>NDF Studio backend is built with: - FastAPI: Modern, fast web framework - SQLModel: SQL databases in Python, designed for compatibility with both SQLAlchemy Core and Pydantic - Pydantic: Data validation using Python type annotations - JWT: Secure authentication with inactivity-based token expiration</p>"},{"location":"#api-examples","title":"\ud83d\udcd6 API Examples","text":""},{"location":"#creating-a-graph","title":"Creating a Graph","text":"<pre><code>import requests\n\n# Create a new graph\nresponse = requests.post(\n    \"http://localhost:8000/api/ndf/users/{user_id}/graphs/{graph_id}\",\n    json={\n        \"title\": \"My Knowledge Graph\",\n        \"description\": \"A graph representing domain knowledge\"\n    }\n)\n</code></pre>"},{"location":"#parsing-cnl","title":"Parsing CNL","text":"<pre><code># Parse CNL (Controlled Natural Language) into graph structure\nwith open(\"graph.cnl\", \"rb\") as f:\n    response = requests.post(\n        \"http://localhost:8000/api/ndf/users/{user_id}/graphs/{graph_id}/parse_pipeline\",\n        files={\"file\": f}\n    )\n</code></pre>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please see our Installation Guide for setup instructions.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api/core/models/","title":"Core Models","text":"<p>This section documents the core data models used throughout the NDF Studio backend.</p>"},{"location":"api/core/models/#backend.core.models","title":"<code>backend.core.models</code>","text":""},{"location":"api/core/utils/","title":"Core Utilities","text":"<p>This section documents the utility functions and helpers used throughout the NDF Studio backend.</p>"},{"location":"api/core/utils/#backend.core.utils","title":"<code>backend.core.utils</code>","text":""},{"location":"api/routes/graph_ops/","title":"Graph Operations","text":"<p>This section documents the graph operation endpoints and their functionality.</p>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops","title":"<code>backend.routes.graph_ops</code>","text":"<p>This module provides API endpoints and helper functions for managing node attributes and relations in the NDF Studio knowledge graph backend.</p> <p>Key Features: - All node data is stored as JSON files under graph_data/users/{user_id}/nodes/{node_id}.json. - Attribute and relation types are validated against global schema files (attribute_types.json, relation_types.json). - Endpoints support full CRUD (create, update, delete) for both attributes and relations. - When creating or updating a relation, if the source or target node does not exist, the canonical create_node function from nodes.py is called to ensure proper node creation and registry updates. - All endpoints are designed for robust integration with the frontend, supporting both selection and creation of new nodes/relations/attributes.</p> <p>Endpoints: - POST   /users/{user_id}/graphs/{graph_id}/attribute/create - PUT    /users/{user_id}/graphs/{graph_id}/attribute/update/{node_id}/{attr_name} - DELETE /users/{user_id}/graphs/{graph_id}/attribute/delete/{node_id}/{attr_name} - POST   /users/{user_id}/graphs/{graph_id}/relation/create - PUT    /users/{user_id}/graphs/{graph_id}/relation/update/{source}/{name}/{target} - DELETE /users/{user_id}/graphs/{graph_id}/relation/delete/{source}/{name}/{target}</p> <p>Helpers: - node_path, load_node, save_node: JSON-based node storage helpers. - load_schema: Loads global schema files for validation.</p> <p>All logic is designed to be robust, extensible, and consistent with the rest of the backend.</p>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops-classes","title":"Classes","text":""},{"location":"api/routes/graph_ops/#backend.routes.graph_ops-functions","title":"Functions","text":""},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_attribute_node","title":"<code>get_attribute_node(user_id: str, graph_id: str, attribute_id: str)</code>","text":"<p>Get a specific attribute node by its ID</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/attributeNodes/{attribute_id}\")\ndef get_attribute_node(user_id: str, graph_id: str, attribute_id: str):\n    \"\"\"Get a specific attribute node by its ID\"\"\"\n    attr_path = f\"graph_data/users/{user_id}/attributeNodes/{attribute_id}.json\"\n    if not os.path.exists(attr_path):\n        raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n    with open(attr_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.unlist_attribute_from_morph","title":"<code>unlist_attribute_from_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Remove an attribute from a specific morph without deleting the attribute itself. The attribute continues to exist in other morphs.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/unlist_from_morph/{node_id}/{attr_name}\")\ndef unlist_attribute_from_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Remove an attribute from a specific morph without deleting the attribute itself.\n    The attribute continues to exist in other morphs.\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"unlist_attribute_from_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to remove attribute from specific morph\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find the specific morph and remove the attribute\n            morph_found = False\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    morph_found = True\n                    if \"attributeNode_ids\" in morph and attr_id in morph[\"attributeNode_ids\"]:\n                        morph[\"attributeNode_ids\"].remove(attr_id)\n                        break\n\n            if not morph_found:\n                raise HTTPException(status_code=404, detail=f\"Morph {morph_id} not found\")\n\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n            return {\"status\": \"Attribute unlisted from morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to unlist attribute from morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.add_attribute_to_morph","title":"<code>add_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Add an existing attribute to a specific morph.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/add_to_morph/{node_id}/{attr_name}\")\ndef add_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Add an existing attribute to a specific morph.\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"add_attribute_to_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to add attribute to specific morph\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find the specific morph and add the attribute\n            morph_found = False\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    morph_found = True\n                    if \"attributeNode_ids\" not in morph:\n                        morph[\"attributeNode_ids\"] = []\n                    if attr_id not in morph[\"attributeNode_ids\"]:\n                        morph[\"attributeNode_ids\"].append(attr_id)\n                    break\n\n            if not morph_found:\n                raise HTTPException(status_code=404, detail=f\"Morph {morph_id} not found\")\n\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n            return {\"status\": \"Attribute added to morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to add attribute to morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.move_attribute_to_morph","title":"<code>move_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MoveMorphRequest)</code>","text":"<p>Move an attribute from one morph to another.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/move_to_morph/{node_id}/{attr_name}\")\ndef move_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MoveMorphRequest):\n    \"\"\"\n    Move an attribute from one morph to another.\n    \"\"\"\n    try:\n        print(f\"[DEBUG] move_attribute_to_morph called: user_id={user_id}, graph_id={graph_id}, node_id={node_id}, attr_name={attr_name}, from_morph_id={request.from_morph_id}, to_morph_id={request.to_morph_id}\")\n        with graph_transaction(user_id, graph_id, \"move_attribute_to_morph\") as backup_dir:\n            from_morph_id = request.from_morph_id\n            to_morph_id = request.to_morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n            print(f\"[DEBUG] Found attr_id: {attr_id}\")\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"AttributeNode not found\")\n\n            # Update source node to move attribute between morphs\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Find both morphs\n            from_morph = None\n            to_morph = None\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == from_morph_id:\n                    from_morph = morph\n                if morph.get(\"morph_id\") == to_morph_id:\n                    to_morph = morph\n            print(f\"[DEBUG] from_morph: {from_morph}\")\n            print(f\"[DEBUG] to_morph: {to_morph}\")\n            if not from_morph:\n                raise HTTPException(status_code=404, detail=f\"Source morph {from_morph_id} not found\")\n            if not to_morph:\n                raise HTTPException(status_code=404, detail=f\"Target morph {to_morph_id} not found\")\n            print(f\"[DEBUG] from_morph attributeNode_ids before: {from_morph.get('attributeNode_ids', [])}\")\n            print(f\"[DEBUG] to_morph attributeNode_ids before: {to_morph.get('attributeNode_ids', [])}\")\n            # Remove from source morph\n            if \"attributeNode_ids\" in from_morph and attr_id in from_morph[\"attributeNode_ids\"]:\n                from_morph[\"attributeNode_ids\"].remove(attr_id)\n            # Add to target morph\n            if \"attributeNode_ids\" not in to_morph:\n                to_morph[\"attributeNode_ids\"] = []\n            if attr_id not in to_morph[\"attributeNode_ids\"]:\n                to_morph[\"attributeNode_ids\"].append(attr_id)\n            print(f\"[DEBUG] from_morph attributeNode_ids after: {from_morph.get('attributeNode_ids', [])}\")\n            print(f\"[DEBUG] to_morph attributeNode_ids after: {to_morph.get('attributeNode_ids', [])}\")\n            # Atomically save updated source node\n            atomic_node_save(user_id, node_id, source_node)\n            # Regenerate composed files atomically\n            try:\n                node_ids = get_graph_node_ids(user_id, graph_id)\n                metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                graph_description = \"\"\n                if metadata_path.exists():\n                    import yaml\n                    with open(metadata_path, \"r\") as f:\n                        metadata = yaml.safe_load(f) or {}\n                        graph_description = metadata.get(\"description\", \"\")\n                composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                if composed_data:\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                    atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n            except Exception as e:\n                print(f\"Warning: Failed to regenerate composed files: {e}\")\n            return {\"status\": \"Attribute moved between morphs\", \"attribute_id\": attr_id, \"from_morph_id\": from_morph_id, \"to_morph_id\": to_morph_id}\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to move attribute between morphs: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.copy_attribute_to_morph","title":"<code>copy_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest)</code>","text":"<p>Copy an existing attribute to a specific morph (keeps it in all other morphs as well).</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/attribute/copy_to_morph/{node_id}/{attr_name}\")\ndef copy_attribute_to_morph(user_id: str, graph_id: str, node_id: str, attr_name: str, request: MorphOperationRequest):\n    \"\"\"\n    Copy an existing attribute to a specific morph (keeps it in all other morphs as well).\n    \"\"\"\n    try:\n        with graph_transaction(user_id, graph_id, \"copy_attribute_to_morph\") as backup_dir:\n            morph_id = request.morph_id\n            # Find the attributeNode id by node_id and attr_name\n            reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n            registry = load_registry(reg_path)\n            attr_id = None\n            for k, v in registry.items():\n                if v.get(\"source_id\") == node_id and v.get(\"name\") == attr_name:\n                    attr_id = k\n                    break\n\n            if not attr_id:\n                raise HTTPException(status_code=404, detail=\"Attribute not found\")\n\n            # Load the source node\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n            source_node = load_json_file(source_node_path)\n\n            # Ensure morphs array exists\n            if \"morphs\" not in source_node:\n                source_node[\"morphs\"] = []\n\n            # Find the target morph\n            target_morph = None\n            for morph in source_node[\"morphs\"]:\n                if morph.get(\"morph_id\") == morph_id:\n                    target_morph = morph\n                    break\n\n            if not target_morph:\n                raise HTTPException(status_code=404, detail=\"Target morph not found\")\n\n            # Ensure attributeNode_ids array exists\n            if \"attributeNode_ids\" not in target_morph:\n                target_morph[\"attributeNode_ids\"] = []\n\n            # Add attribute to the morph if not already present\n            if attr_id not in target_morph[\"attributeNode_ids\"]:\n                target_morph[\"attributeNode_ids\"].append(attr_id)\n\n                # Atomically save the updated node\n                atomic_node_save(user_id, node_id, source_node)\n\n                # Regenerate composed files\n                try:\n                    node_ids = get_graph_node_ids(user_id, graph_id)\n                    metadata_path = Path(f\"graph_data/users/{user_id}/graphs/{graph_id}/metadata.yaml\")\n                    graph_description = \"\"\n                    if metadata_path.exists():\n                        import yaml\n                        with open(metadata_path, \"r\") as f:\n                            metadata = yaml.safe_load(f) or {}\n                            graph_description = metadata.get(\"description\", \"\")\n\n                    composed_data = compose_graph(user_id, graph_id, node_ids, graph_description)\n                    if composed_data:\n                        atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"json\")\n                        atomic_composed_save(user_id, graph_id, composed_data[\"cytoscape\"], \"yaml\")\n                        atomic_composed_save(user_id, graph_id, composed_data[\"polymorphic\"], \"polymorphic\")\n                except Exception as e:\n                    print(f\"Warning: Failed to regenerate composed files: {e}\")\n\n                return {\"status\": \"Attribute copied to morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n            else:\n                return {\"status\": \"Attribute already exists in target morph\", \"attribute_id\": attr_id, \"morph_id\": morph_id}\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to copy attribute to morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.list_attributes_by_morph","title":"<code>list_attributes_by_morph(user_id: str, graph_id: str, node_id: str)</code>","text":"<p>List all attributes organized by morph for a given node.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/attribute/list_by_morph/{node_id}\")\ndef list_attributes_by_morph(user_id: str, graph_id: str, node_id: str):\n    \"\"\"\n    List all attributes organized by morph for a given node.\n    \"\"\"\n    try:\n        # Load source node\n        source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n        if not source_node_path.exists():\n            raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n        source_node = load_json_file(source_node_path)\n\n        # Load attribute registry\n        reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n        registry = load_registry(reg_path)\n\n        # Organize attributes by morph\n        morph_attributes = {}\n        for morph in source_node.get(\"morphs\", []):\n            morph_id = morph.get(\"morph_id\")\n            morph_name = morph.get(\"name\", \"Unknown\")\n            morph_attributes[morph_id] = {\n                \"morph_id\": morph_id,\n                \"morph_name\": morph_name,\n                \"attributes\": []\n            }\n\n            for attr_id in morph.get(\"attributeNode_ids\", []):\n                if attr_id in registry:\n                    attr_info = registry[attr_id]\n\n                    # Load full attribute data from the attribute file\n                    attr_file_path = Path(f\"graph_data/users/{user_id}/attributeNodes/{attr_id}.json\")\n                    full_attr_data = {}\n                    if attr_file_path.exists():\n                        try:\n                            full_attr_data = load_json_file(attr_file_path)\n                        except Exception as e:\n                            print(f\"Warning: Failed to load attribute file {attr_id}: {e}\")\n\n                    # Combine registry info with full attribute data\n                    attribute_data = {\n                        \"attribute_id\": attr_id,\n                        \"name\": attr_info.get(\"name\"),\n                        \"source_id\": attr_info.get(\"source_id\"),\n                        \"value\": full_attr_data.get(\"value\"),\n                        \"unit\": full_attr_data.get(\"unit\"),\n                        \"adverb\": full_attr_data.get(\"adverb\"),\n                        \"modality\": full_attr_data.get(\"modality\")\n                    }\n\n                    morph_attributes[morph_id][\"attributes\"].append(attribute_data)\n\n        return {\"node_id\": node_id, \"morphs\": morph_attributes}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to list attributes by morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.list_relations_by_morph","title":"<code>list_relations_by_morph(user_id: str, graph_id: str, node_id: str)</code>","text":"<p>List all relations organized by morph for a given node.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/relation/list_by_morph/{node_id}\")\ndef list_relations_by_morph(user_id: str, graph_id: str, node_id: str):\n    \"\"\"\n    List all relations organized by morph for a given node.\n    \"\"\"\n    try:\n        # Load source node\n        source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n        if not source_node_path.exists():\n            raise HTTPException(status_code=404, detail=\"Source node not found\")\n\n        source_node = load_json_file(source_node_path)\n\n        # Load relation registry\n        reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n        registry = load_registry(reg_path)\n\n        # Organize relations by morph\n        morph_relations = {}\n        for morph in source_node.get(\"morphs\", []):\n            morph_id = morph.get(\"morph_id\")\n            morph_name = morph.get(\"name\", \"Unknown\")\n            morph_relations[morph_id] = {\n                \"morph_id\": morph_id,\n                \"morph_name\": morph_name,\n                \"relations\": []\n            }\n\n            for rel_id in morph.get(\"relationNode_ids\", []):\n                if rel_id in registry:\n                    rel_info = registry[rel_id]\n\n                    # Load full relation data from the relation file\n                    rel_file_path = Path(f\"graph_data/users/{user_id}/relationNodes/{rel_id}.json\")\n                    full_rel_data = {}\n                    if rel_file_path.exists():\n                        try:\n                            full_rel_data = load_json_file(rel_file_path)\n                        except Exception as e:\n                            print(f\"Warning: Failed to load relation file {rel_id}: {e}\")\n\n                    # Combine registry info with full relation data\n                    relation_data = {\n                        \"relation_id\": rel_id,\n                        \"name\": rel_info.get(\"name\"),\n                        \"source_id\": rel_info.get(\"source_id\"),\n                        \"target_id\": rel_info.get(\"target_id\"),\n                        \"adverb\": full_rel_data.get(\"adverb\"),\n                        \"modality\": full_rel_data.get(\"modality\")\n                    }\n\n                    morph_relations[morph_id][\"relations\"].append(relation_data)\n\n        return {\"node_id\": node_id, \"morphs\": morph_relations}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to list relations by morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.create_morph","title":"<code>create_morph(user_id: str, graph_id: str, request: CreateMorphRequest)</code>","text":"<p>Create a new morph for a node.</p> <p>Scenarios: 1. Empty morph: copy_from_morph is None - creates morph with empty properties 2. Copy from existing morph: copy_from_morph specifies any existing morph to copy from 3. Node context is always required - morphs must belong to a node</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/morph/create\")\ndef create_morph(user_id: str, graph_id: str, request: CreateMorphRequest):\n    \"\"\"\n    Create a new morph for a node.\n\n    Scenarios:\n    1. Empty morph: copy_from_morph is None - creates morph with empty properties\n    2. Copy from existing morph: copy_from_morph specifies any existing morph to copy from\n    3. Node context is always required - morphs must belong to a node\n    \"\"\"\n    try:\n        print(f\"DEBUG: Morph creation called with:\")\n        print(f\"  user_id: {user_id}\")\n        print(f\"  graph_id: {graph_id}\")\n        print(f\"  node_id: {request.node_id}\")\n        print(f\"  name: {request.name}\")\n        print(f\"  copy_from_morph: {request.copy_from_morph}\")\n        print(f\"  auto-generated morph_id: {request.name}_{request.node_id}\")\n\n        with graph_transaction(user_id, graph_id, \"create_morph\") as backup_dir:\n            # Auto-generate morph_id from name and node_id\n            morph_id = f\"{request.name}_{request.node_id}\"\n            node_id = request.node_id\n            morph_name = request.name\n            copy_from_morph = request.copy_from_morph\n\n            # Load the source node (required context)\n            source_node_path = Path(f\"graph_data/users/{user_id}/nodes/{node_id}.json\")\n            if not source_node_path.exists():\n                raise HTTPException(status_code=404, detail=f\"Node {node_id} not found\")\n\n            with open(source_node_path, 'r') as f:\n                source_node = json.load(f)\n\n            # Check if morph already exists\n            existing_morph = None\n            for morph in source_node.get(\"morphs\", []):\n                if morph.get(\"morph_id\") == morph_id:\n                    existing_morph = morph\n                    break\n\n            if existing_morph:\n                # Morph already exists, but we need to ensure registries are updated\n                print(f\"DEBUG: Morph {morph_id} already exists, checking registry updates\")\n\n                # If copying from another morph, ensure registries are updated\n                if copy_from_morph:\n                    print(f\"DEBUG: Updating registries for existing morph {morph_id}\")\n\n                    # Update registries to include the morph_id for all relations and attributes\n                    # Update relation registry\n                    rel_reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n                    if rel_reg_path.exists():\n                        rel_registry = load_json_file(rel_reg_path)\n                        for rel_id in existing_morph.get(\"relationNode_ids\", []):\n                            if rel_id in rel_registry:\n                                current_morph_ids = rel_registry[rel_id].get(\"morph_id\", [])\n                                if isinstance(current_morph_ids, str):\n                                    current_morph_ids = [current_morph_ids]\n                                if morph_id not in current_morph_ids:\n                                    current_morph_ids.append(morph_id)\n                                    rel_registry[rel_id][\"morph_id\"] = current_morph_ids\n                        atomic_registry_save(user_id, \"relation\", rel_registry)\n\n                    # Update attribute registry\n                    attr_reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n                    if attr_reg_path.exists():\n                        attr_registry = load_json_file(attr_reg_path)\n                        for attr_id in existing_morph.get(\"attributeNode_ids\", []):\n                            if attr_id in attr_registry:\n                                current_morph_ids = attr_registry[attr_id].get(\"morph_id\", [])\n                                if isinstance(current_morph_ids, str):\n                                    current_morph_ids = [current_morph_ids]\n                                if morph_id not in current_morph_ids:\n                                    current_morph_ids.append(morph_id)\n                                    attr_registry[attr_id][\"morph_id\"] = current_morph_ids\n                        atomic_registry_save(user_id, \"attribute\", attr_registry)\n\n                # Return success if morph already exists (idempotent behavior)\n                return {\n                    \"status\": \"Morph already exists\",\n                    \"morph_id\": morph_id,\n                    \"node_id\": node_id,\n                    \"name\": morph_name,\n                    \"copied_from\": copy_from_morph,\n                    \"relation_count\": len(existing_morph.get(\"relationNode_ids\", [])),\n                    \"attribute_count\": len(existing_morph.get(\"attributeNode_ids\", []))\n                }\n\n            # Create new morph\n            new_morph = {\n                \"morph_id\": morph_id,\n                \"node_id\": node_id,\n                \"name\": morph_name,\n                \"relationNode_ids\": [],\n                \"attributeNode_ids\": []\n            }\n\n            # If copying from another morph, copy all properties\n            print(f\"DEBUG: About to check copy_from_morph condition: {copy_from_morph}\")\n            print(f\"DEBUG: copy_from_morph type: {type(copy_from_morph)}\")\n            print(f\"DEBUG: copy_from_morph truthiness: {bool(copy_from_morph)}\")\n            if copy_from_morph:\n                print(f\"DEBUG: Copying from morph: {copy_from_morph}\")\n                # Reload the node file to ensure latest state\n                with open(source_node_path, 'r') as f:\n                    source_node = json.load(f)\n                print(f\"DEBUG: Loaded source node with {len(source_node.get('morphs', []))} morphs\")\n                source_morph = None\n                for morph in source_node.get(\"morphs\", []):\n                    print(f\"DEBUG: Checking morph: {morph.get('morph_id')}\")\n                    if morph.get(\"morph_id\") == copy_from_morph:\n                        source_morph = morph\n                        print(f\"DEBUG: Found source morph: {copy_from_morph}\")\n                        break\n\n                if not source_morph:\n                    print(f\"DEBUG: Source morph {copy_from_morph} not found!\")\n                    raise HTTPException(status_code=404, detail=f\"Source morph {copy_from_morph} not found in node {node_id}\")\n\n                print(f\"DEBUG: Copying from source morph {copy_from_morph}\")\n                print(f\"DEBUG: Source morph relationNode_ids: {source_morph.get('relationNode_ids', [])}\")\n                print(f\"DEBUG: Source morph attributeNode_ids: {source_morph.get('attributeNode_ids', [])}\")\n\n                # Copy relations and attributes\n                new_morph[\"relationNode_ids\"] = source_morph.get(\"relationNode_ids\", []).copy()\n                new_morph[\"attributeNode_ids\"] = source_morph.get(\"attributeNode_ids\", []).copy()\n\n                print(f\"DEBUG: New morph relationNode_ids: {new_morph['relationNode_ids']}\")\n                print(f\"DEBUG: New morph attributeNode_ids: {new_morph['attributeNode_ids']}\")\n\n                # Update registries to include the new morph_id for all copied relations and attributes\n                # Update relation registry\n                rel_reg_path = Path(f\"graph_data/users/{user_id}/relation_registry.json\")\n                print(f\"DEBUG: Checking relation registry at {rel_reg_path}\")\n                print(f\"DEBUG: Relation registry exists: {rel_reg_path.exists()}\")\n                if rel_reg_path.exists():\n                    rel_registry = load_json_file(rel_reg_path)\n                    print(f\"DEBUG: Current relation registry keys: {list(rel_registry.keys())}\")\n                    for rel_id in new_morph[\"relationNode_ids\"]:\n                        print(f\"DEBUG: Processing relation {rel_id}\")\n                        if rel_id in rel_registry:\n                            current_morph_ids = rel_registry[rel_id].get(\"morph_id\", [])\n                            print(f\"DEBUG: Current morph_ids for {rel_id}: {current_morph_ids}\")\n                            if isinstance(current_morph_ids, str):\n                                current_morph_ids = [current_morph_ids]\n                            if morph_id not in current_morph_ids:\n                                current_morph_ids.append(morph_id)\n                            print(f\"DEBUG: Updated morph_ids for {rel_id}: {current_morph_ids}\")\n                            rel_registry[rel_id][\"morph_id\"] = current_morph_ids\n                        else:\n                            print(f\"DEBUG: Relation {rel_id} not found in registry\")\n                    print(f\"DEBUG: Saving updated relation registry\")\n                    atomic_registry_save(user_id, \"relation\", rel_registry)\n\n                # Update attribute registry\n                attr_reg_path = Path(f\"graph_data/users/{user_id}/attribute_registry.json\")\n                print(f\"DEBUG: Checking attribute registry at {attr_reg_path}\")\n                print(f\"DEBUG: Attribute registry exists: {attr_reg_path.exists()}\")\n                if attr_reg_path.exists():\n                    attr_registry = load_json_file(attr_reg_path)\n                    print(f\"DEBUG: Current attribute registry keys: {list(attr_registry.keys())}\")\n                    for attr_id in new_morph[\"attributeNode_ids\"]:\n                        print(f\"DEBUG: Processing attribute {attr_id}\")\n                        if attr_id in attr_registry:\n                            current_morph_ids = attr_registry[attr_id].get(\"morph_id\", [])\n                            print(f\"DEBUG: Current morph_ids for {attr_id}: {current_morph_ids}\")\n                            if isinstance(current_morph_ids, str):\n                                current_morph_ids = [current_morph_ids]\n                            if morph_id not in current_morph_ids:\n                                current_morph_ids.append(morph_id)\n                            print(f\"DEBUG: Updated morph_ids for {attr_id}: {current_morph_ids}\")\n                            attr_registry[attr_id][\"morph_id\"] = current_morph_ids\n                        else:\n                            print(f\"DEBUG: Attribute {attr_id} not found in registry\")\n                    print(f\"DEBUG: Saving updated attribute registry\")\n                    atomic_registry_save(user_id, \"attribute\", attr_registry)\n                else:\n                    print(f\"DEBUG: Attribute registry does not exist\")\n\n            # Add new morph to node\n            if \"morphs\" not in source_node:\n                source_node[\"morphs\"] = []\n            source_node[\"morphs\"].append(new_morph)\n\n            # Save updated node\n            with open(source_node_path, 'w') as f:\n                json.dump(source_node, f, indent=2)\n\n            return {\n                \"status\": \"Morph created successfully\",\n                \"morph_id\": morph_id,\n                \"node_id\": node_id,\n                \"name\": morph_name,\n                \"copied_from\": copy_from_morph,\n                \"relation_count\": len(new_morph[\"relationNode_ids\"]),\n                \"attribute_count\": len(new_morph[\"attributeNode_ids\"]),\n                \"is_empty\": copy_from_morph is None\n            }\n\n    except AtomicityError as e:\n        raise HTTPException(status_code=500, detail=f\"Atomic operation failed: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to create morph: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_graph_node_ids","title":"<code>get_graph_node_ids(user_id: str, graph_id: str) -&gt; list[str]</code>","text":"<p>Get list of node IDs that belong to a specific graph</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>def get_graph_node_ids(user_id: str, graph_id: str) -&gt; list[str]:\n    \"\"\"Get list of node IDs that belong to a specific graph\"\"\"\n    from backend.core.registry import load_node_registry\n    registry = load_node_registry(user_id)\n    graph_nodes = []\n\n    for node_id, entry in registry.items():\n        if \"graphs\" in entry and graph_id in entry[\"graphs\"]:\n            graph_nodes.append(node_id)\n\n    return graph_nodes\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.get_relation_node","title":"<code>get_relation_node(user_id: str, graph_id: str, relation_id: str)</code>","text":"<p>Get a specific relation node by its ID</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/relationNodes/{relation_id}\")\ndef get_relation_node(user_id: str, graph_id: str, relation_id: str):\n    \"\"\"Get a specific relation node by its ID\"\"\"\n    rel_path = f\"graph_data/users/{user_id}/relationNodes/{relation_id}.json\"\n    if not os.path.exists(rel_path):\n        raise HTTPException(status_code=404, detail=\"RelationNode not found\")\n    with open(rel_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.validate_graph_consistency","title":"<code>validate_graph_consistency(user_id: str, graph_id: str)</code>","text":"<p>Validate the consistency of a graph's data.</p> <p>This endpoint performs comprehensive validation of: - Node registry consistency - Relation registry consistency - Attribute registry consistency - File existence checks - Reference integrity</p> <p>Returns validation results with issues and warnings.</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.get(\"/users/{user_id}/graphs/{graph_id}/validate\")\ndef validate_graph_consistency(user_id: str, graph_id: str):\n    \"\"\"\n    Validate the consistency of a graph's data.\n\n    This endpoint performs comprehensive validation of:\n    - Node registry consistency\n    - Relation registry consistency  \n    - Attribute registry consistency\n    - File existence checks\n    - Reference integrity\n\n    Returns validation results with issues and warnings.\n    \"\"\"\n    try:\n        validation_result = validate_consistency(user_id)\n        return validation_result\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Validation failed: {str(e)}\")\n</code></pre>"},{"location":"api/routes/graph_ops/#backend.routes.graph_ops.cleanup_old_backups","title":"<code>cleanup_old_backups(user_id: str, graph_id: str, max_age_hours: int = 24)</code>","text":"<p>Clean up old backup directories for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID</p> required <code>graph_id</code> <code>str</code> <p>Graph ID (not used but kept for consistency)</p> required <code>max_age_hours</code> <code>int</code> <p>Maximum age of backups to keep (default: 24 hours)</p> <code>24</code> <p>Returns:</p> Type Description <p>Number of backups cleaned up</p> Source code in <code>backend/routes/graph_ops.py</code> <pre><code>@router.post(\"/users/{user_id}/graphs/{graph_id}/cleanup-backups\")\ndef cleanup_old_backups(user_id: str, graph_id: str, max_age_hours: int = 24):\n    \"\"\"\n    Clean up old backup directories for a user.\n\n    Args:\n        user_id: User ID\n        graph_id: Graph ID (not used but kept for consistency)\n        max_age_hours: Maximum age of backups to keep (default: 24 hours)\n\n    Returns:\n        Number of backups cleaned up\n    \"\"\"\n    try:\n        cleaned_count = cleanup_backups(user_id, max_age_hours)\n        return {\n            \"status\": \"Backup cleanup completed\",\n            \"cleaned_count\": cleaned_count,\n            \"max_age_hours\": max_age_hours\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Backup cleanup failed: {str(e)}\")\n</code></pre>"},{"location":"development/installation/","title":"Installation Guide","text":"<p>This guide will help you set up the NDF Studio backend for development.</p>"},{"location":"development/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+: The backend requires Python 3.8 or higher</li> <li>Git: For cloning the repository</li> <li>Virtual Environment: Recommended for Python dependency management</li> </ul>"},{"location":"development/installation/#step-by-step-installation","title":"Step-by-Step Installation","text":""},{"location":"development/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/gnowledge/nodeBook.git\ncd nodeBook\n</code></pre>"},{"location":"development/installation/#2-set-up-python-virtual-environment","title":"2. Set Up Python Virtual Environment","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On Linux/macOS:\nsource venv/bin/activate\n# On Windows:\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"development/installation/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code># Install Python dependencies\npip install -r backend/requirements.txt\n\n# Install spaCy model (required for CNL parsing)\npython -m spacy download en_core_web_sm\n</code></pre>"},{"location":"development/installation/#4-set-up-environment-variables","title":"4. Set Up Environment Variables","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Backend configuration\nBACKEND_HOST=localhost\nBACKEND_PORT=8000\nDEBUG=True\n\n# Database configuration\nDATABASE_URL=sqlite:///./ndf_studio.db\n\n# JWT configuration\nJWT_SECRET_KEY=your-secret-key-here\nJWT_ALGORITHM=HS256\nJWT_ACCESS_TOKEN_EXPIRE_MINUTES=30\n\n# spaCy model\nSPACY_MODEL=en_core_web_sm\n</code></pre>"},{"location":"development/installation/#5-initialize-the-database","title":"5. Initialize the Database","text":"<pre><code># Run database migrations (if using Alembic)\n# alembic upgrade head\n\n# Or create initial database\npython -c \"from backend.core.models import *; from backend.config import get_data_root; print('Database initialized')\"\n</code></pre>"},{"location":"development/installation/#6-create-admin-user","title":"6. Create Admin User","text":"<pre><code># Run the post-install script to create admin user\npython scripts/post_install.py\n</code></pre>"},{"location":"development/installation/#running-the-application","title":"Running the Application","text":""},{"location":"development/installation/#development-server","title":"Development Server","text":"<pre><code># Start the backend server\nbash scripts/start_backend.sh\n\n# Or manually\ncd backend\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"development/installation/#production-server","title":"Production Server","text":"<pre><code># For production deployment\ncd backend\nuvicorn main:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"development/installation/#verification","title":"Verification","text":"<p>Once the server is running, you can verify the installation:</p> <ol> <li>Health Check: Visit <code>http://localhost:8000/api/health</code></li> <li>API Documentation: Visit <code>http://localhost:8000/docs</code></li> <li>Alternative Docs: Visit <code>http://localhost:8000/redoc</code></li> </ol>"},{"location":"development/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/installation/#common-issues","title":"Common Issues","text":""},{"location":"development/installation/#import-errors","title":"Import Errors","text":"<p>If you encounter import errors, ensure you're in the correct directory and the virtual environment is activated:</p> <pre><code># Make sure you're in the project root\npwd  # Should show /path/to/nodeBook\n\n# Activate virtual environment\nsource venv/bin/activate\n\n# Check Python path\npython -c \"import sys; print('\\n'.join(sys.path))\"\n</code></pre>"},{"location":"development/installation/#spacy-model-issues","title":"spaCy Model Issues","text":"<p>If spaCy model is not found:</p> <pre><code># Reinstall spaCy model\npython -m spacy download en_core_web_sm\n\n# Verify installation\npython -c \"import spacy; nlp = spacy.load('en_core_web_sm'); print('spaCy model loaded successfully')\"\n</code></pre>"},{"location":"development/installation/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 8000 is already in use:</p> <pre><code># Find process using port 8000\nlsof -i :8000\n\n# Kill the process\nkill -9 &lt;PID&gt;\n\n# Or use a different port\nuvicorn main:app --reload --host 0.0.0.0 --port 8001\n</code></pre>"},{"location":"development/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Check the API Reference for available endpoints</li> <li>Run tests with <code>bash run_tests.sh</code></li> <li>Explore the codebase in the <code>backend/</code> directory </li> </ol>"}]}